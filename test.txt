import pandas as pd
from sktime.forecasting.model_selection import temporal_train_test_split
from sktime.forecasting.compose import make_reduction
from sktime.forecasting.compose import EnsembleForecaster, StackingForecaster
from sktime.forecasting.arima import AutoARIMA
from sktime.forecasting.ets import ExponentialSmoothing
from sktime.forecasting.theta import ThetaForecaster
from sktime.forecasting.naive import NaiveForecaster
from sktime.forecasting.exp_smoothing import ExponentialSmoothing
from sktime.performance_metrics.forecasting import mean_absolute_percentage_error, mean_squared_error, mean_absolute_error
from sklearn.ensemble import RandomForestRegressor
from sklearn.linear_model import LinearRegression

# Load and prepare your data
# Assuming df_agg_daily is already prepared and cleaned
df_agg_daily = pd.read_csv("path_to_your_data.csv")  # Replace with your actual data path
df_agg_daily['date'] = pd.to_datetime(df_agg_daily['date'])
df_agg_daily.set_index('date', inplace=True)

# Select the target series
y = df_agg_daily['count']

# Split data into training and testing sets
y_train, y_test = temporal_train_test_split(y, test_size=365)

# Define the models
forecasters = [
    ("AutoARIMA", AutoARIMA()),
    ("ETS", ExponentialSmoothing(trend="add", seasonal="add", sp=12)),
    ("Theta", ThetaForecaster(sp=12)),
    ("SeasonalNaive", NaiveForecaster(strategy="seasonal_last", sp=12)),
    ("RandomForest", make_reduction(RandomForestRegressor(), window_length=12, strategy="recursive")),
    ("LinearRegression", make_reduction(LinearRegression(), window_length=12, strategy="recursive"))
]

# Ensemble forecaster
ensemble_forecaster = EnsembleForecaster(forecasters)

# Stacking forecaster
stacking_forecaster = StackingForecaster(forecasters)

# Fit the models
ensemble_forecaster.fit(y_train)
stacking_forecaster.fit(y_train)

# Predict
y_pred_ensemble = ensemble_forecaster.predict(fh=len(y_test))
y_pred_stacking = stacking_forecaster.predict(fh=len(y_test))

# Collect metrics
metrics = {
    "Model": ["Ensemble", "Stacking"],
    "MAPE": [
        mean_absolute_percentage_error(y_test, y_pred_ensemble),
        mean_absolute_percentage_error(y_test, y_pred_stacking)
    ],
    "RMSE": [
        mean_squared_error(y_test, y_pred_ensemble, squared=False),
        mean_squared_error(y_test, y_pred_stacking, squared=False)
    ],
    "MAE": [
        mean_absolute_error(y_test, y_pred_ensemble),
        mean_absolute_error(y_test, y_pred_stacking)
    ]
}
metrics_df = pd.DataFrame(metrics)

# Collect forecasts
forecasts_df = pd.DataFrame({
    "Date": y_test.index,
    "Actual": y_test.values,
    "Ensemble_Forecast": y_pred_ensemble.values,
    "Stacking_Forecast": y_pred_stacking.values
})

# Print metrics
print(metrics_df)

# Plot forecasts
import matplotlib.pyplot as plt

plt.figure(figsize=(10, 6))
y_train.plot(label="Training Data")
y_test.plot(label="Actual")
y_pred_ensemble.plot(label="Ensemble Forecast")
y_pred_stacking.plot(label="Stacking Forecast")
plt.legend()
plt.show()
